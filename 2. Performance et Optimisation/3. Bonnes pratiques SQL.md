# Bonnes pratiques SQL

## Principe général
Règle d'or : faire le moins de travail possible.

- Filtrer tôt (`WHERE` avant `JOIN`)
- Sélectionner peu de colonnes
- Limiter les résultats (`LIMIT`)

## 1. Sélection de colonnes
Mauvais :
```sql
SELECT *
FROM olist_orders_dataset;
```
Problèmes :
Lit toutes les colonnes (inutile)
Transfert de données volumineux
Cache moins efficace

Bon :
```sql
SELECT order_id, customer_id, order_purchase_timestamp
FROM olist_orders_dataset;
```

Testez les deux !

## 2. Filtrage WHERE
Mauvais :
```sql
SELECT customer_id
FROM olist_customers_dataset
WHERE UPPER(customer_state) = 'SP';
```

Problème : Fonction sur colonne → Index inutilisable

Bon :
```sql
SELECT customer_id
FROM olist_customers_dataset
WHERE customer_state = 'Sp';
```
OU stocker déjà en uppercase.
!! éviter les fonctions sur les colonnes filtrées (dans le WHERE) pour permettre l'utilisation d'index.

## 3. ORDER BY et LIMIT
Mauvais :
```sql
SELECT order_id, order_purchase_timestamp
FROM olist_orders_dataset
ORDER BY order_purchase_timestamp DESC;
```
-- Trie TOUS les commandes alors qu'on en veut 100

Bon :
```sql
SELECT order_id, order_purchase_timestamp
FROM olist_orders_dataset
ORDER BY order_purchase_timestamp DESC
LIMIT 100;
```
-- Optimiseur peut arrêter après 100

## 4. JOIN efficaces
Mauvais :
```sql
SELECT *
FROM olist_orders_dataset o, olist_order_items_dataset oi
WHERE o.order_id = oi.order_id;
```
-- Cartesian product puis filtre (lent)

Bon :
```sql
SELECT o.order_id, o.customer_id, oi.product_id, oi.price
FROM olist_orders_dataset o
JOIN olist_order_items_dataset oi ON oi.order_id = o.order_id;
```
-- JOIN explicite (optimisé)

## 5. Sous-requêtes vs CTE
Mauvais (si calcul répété) :
```sql
SELECT op.order_id, op.payment_value
FROM olist_order_payments_dataset op
WHERE op.payment_value > (
    SELECT AVG(payment_value) FROM olist_order_payments_dataset
)
AND EXISTS (
    SELECT 1
    FROM olist_order_payments_dataset op2
    WHERE op2.order_id = op.order_id
      AND op2.payment_value > (
          SELECT AVG(payment_value) FROM olist_order_payments_dataset
      )
);
```
Problème : Calcule AVG plusieurs fois

Bon :
```sql
WITH avg_payment AS (
    SELECT AVG(payment_value) AS avg_value
    FROM olist_order_payments_dataset
)
SELECT op.order_id, op.payment_value
FROM olist_order_payments_dataset op
CROSS JOIN avg_payment ap
WHERE op.payment_value > ap.avg_value;
```
Calcul de AVG une fois, plus lisible.

## 6. EXISTS vs IN
Quand utiliser `EXISTS` (grand volume/table) :
```sql
SELECT o.order_id
FROM olist_orders_dataset o
WHERE EXISTS (
    SELECT 1
    FROM olist_order_items_dataset oi
    JOIN olist_sellers_dataset s ON s.seller_id = oi.seller_id
    WHERE oi.order_id = o.order_id
      AND s.seller_state = 'SP'
);
```
S'arrête dès qu'une ligne est trouvée, plus rapide pour grandes tables.

Quand utiliser `IN` (petite liste) :
```sql
SELECT order_id
FROM olist_orders_dataset
WHERE order_status IN ('delivered', 'shipped');
```
Liste courte, évaluation rapide.

## 7. DISTINCT vs GROUP BY
`DISTINCT` simple (moins efficace) :
```sql
SELECT DISTINCT customer_state
FROM olist_customers_dataset;
```

`GROUP BY` (plus efficace si agrégation) :
```sql
SELECT customer_state, COUNT(*)
FROM olist_customers_dataset
GROUP BY customer_state;
```

## 8. Éviter les NOT IN avec NULL
Dangereux :
```sql
SELECT o.order_id
FROM olist_orders_dataset o
WHERE o.order_id NOT IN (
    SELECT r.order_id
    FROM olist_order_reviews_dataset r
);
```
Si `olist_order_reviews_dataset` contient des `order_id` NULL, la requête ne retournera aucun résultat.

Sûr :
```sql
SELECT o.order_id
FROM olist_orders_dataset o
WHERE NOT EXISTS (
    SELECT 1
    FROM olist_order_reviews_dataset r
    WHERE r.order_id = o.order_id
);
```
OU
```sql
SELECT o.order_id
FROM olist_orders_dataset oWHERE o.order_id NOT IN (
    SELECT r.order_id
    FROM olist_order_reviews_dataset r
    WHERE r.order_id IS NOT NULL
);
```

## 9. Préférer CTE aux sous-requêtes imbriquées
Difficile à lire :
```sql
SELECT order_id, customer_id
FROM (
    SELECT order_id, customer_id, order_purchase_timestamp
    FROM (
        SELECT *
        FROM olist_orders_dataset
        WHERE order_status = 'delivered'
    ) t1
    WHERE order_purchase_timestamp >= '2018-01-01'
) t2;
```

Lisible :
```sql
WITH delivered_orders AS (
    SELECT order_id, customer_id, order_purchase_timestamp
    FROM olist_orders_dataset
    WHERE order_status = 'delivered'
),
recent_orders AS (
    SELECT order_id, customer_id
    FROM delivered_orders
    WHERE order_purchase_timestamp >= '2018-01-01'
)
SELECT order_id, customer_id
FROM recent_orders;
```

## 10. LIMIT pour tests
```sql
-- Développement
SELECT * FROM olist_order_items_dataset LIMIT 10;

-- Production (si besoin de tout)
SELECT * FROM olist_order_items_dataset;
```

## Checklist performance
- Ai-je besoin de toutes ces colonnes ?
- Puis-je filtrer plus tôt ?
- Ai-je un `LIMIT` approprié ?
- Mes colonnes de `WHERE/JOIN` sont-elles indexées ?
- Ai-je testé avec `EXPLAIN` ?
- Mes CTE évitent-elles les recalculs ?

## Exercice
Optimisez cette requête :
```sql
SELECT *
FROM olist_orders_dataset
WHERE UPPER(order_status) = 'DELIVERED'
ORDER BY order_purchase_timestamp DESC;
```

Solution possible :
```sql
SELECT order_id, customer_id, order_status, order_purchase_timestamp -- Pas SELECT *
FROM olist_orders_dataset
WHERE order_status = 'delivered' -- Pas UPPER() sur colonne
ORDER BY order_purchase_timestamp DESC
LIMIT 100; -- Ajouter LIMIT si pas besoin de tout
```

Résumé
- Sélectionner uniquement les colonnes nécessaires
- Filtrer tôt et éviter les fonctions sur les colonnes filtrées
- Limiter les résultats pour les tests et si pas besoin de tout
- Utiliser des JOIN explicites avec des colonnes indexées
- Préférer les CTE pour la lisibilité/réutilisation et éviter les recalculs
- Utiliser EXISTS pour les grandes tables, IN pour les petites listes