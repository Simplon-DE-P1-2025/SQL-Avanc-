# Performance avancée et monitoring

## Introduction
Techniques avancées pour maximiser les performances SQL et surveiller la santé de vos requêtes.

## 1. Partitionnement
Diviser une grande table en partitions plus petites.

```sql
-- Illustration : partitionnement annuel
-- olist_orders_2016, olist_orders_2017, olist_orders_2018

SELECT *
FROM olist_orders_dataset
WHERE order_purchase_timestamp >= '2018-01-01'
  AND order_purchase_timestamp < '2019-01-01';
```

Avantages :
- Scan plus rapide
- Maintenance par partition (`VACUUM`, `ANALYZE`)
- Archivage simplifié

## 2. Materialized Views (vues matérialisées)
Pré-calculer des agrégations coûteuses.

```sql
CREATE MATERIALIZED VIEW mv_olist_sales_by_category_month AS
SELECT
    DATE_TRUNC('month', o.order_purchase_timestamp) AS month_start,
    p.product_category_name,
    SUM(oi.price + oi.freight_value) AS sales_amount,
    COUNT(DISTINCT o.order_id) AS orders_count
FROM olist_orders_dataset o
JOIN olist_order_items_dataset oi ON oi.order_id = o.order_id
JOIN olist_products_dataset p ON p.product_id = oi.product_id
GROUP BY 1, 2;

SELECT *
FROM mv_olist_sales_by_category_month;
```

Mise à jour :
```sql
REFRESH MATERIALIZED VIEW mv_olist_sales_by_category_month;
```

## 3. Cache et pagination
Mauvais (`OFFSET` lent) :
```sql
SELECT order_id, order_purchase_timestamp
FROM olist_orders_dataset
ORDER BY order_purchase_timestamp DESC, order_id DESC
OFFSET 10000 LIMIT 100;
```
-- Lit 10100 lignes, garde 100.

Bon (keyset pagination) :
```sql
-- Page 1
SELECT order_id, order_purchase_timestamp
FROM olist_orders_dataset
ORDER BY order_purchase_timestamp DESC, order_id DESC
LIMIT 100;

-- Page suivante avec curseur
SELECT order_id, order_purchase_timestamp
FROM olist_orders_dataset
WHERE (order_purchase_timestamp, order_id) < ('2018-08-01 10:00:00', 'f9e4b658b201a9f2ecdecbb34bed034b')
ORDER BY order_purchase_timestamp DESC, order_id DESC
LIMIT 100;
```

## 4. Batch processing
Traiter par lots au lieu d'une transaction géante.

-- Mauvais : UPDATE 1M lignes en 1 fois
```sql
UPDATE olist_order_items_dataset
SET freight_value = freight_value * 1.02;
```

-- Bon : Par lots de 1000
```sql
UPDATE olist_order_items_dataset
SET freight_value = freight_value * 1.02
WHERE order_id IN (
    SELECT order_id
    FROM olist_orders_dataset
    ORDER BY order_purchase_timestamp
    LIMIT 1000 OFFSET 0
);
```
-- Répéter avec OFFSET 1000, 2000, etc.

## 5. Vacuum et maintenance
```sql
VACUUM; -- Nettoyer l'espace disque 
VACUUM ANALYZE; -- Réorganiser les données et mettre à jour les statistiques pour l'optimiseur
```
Quand : après gros `DELETE/UPDATE`.

## 6. Checklist monitoring
À surveiller :
- Temps moyen d'exécution par type de requête
- Nombre de scans complets : `SEQ_SCAN`
- Ratio cache hit/miss
- Croissance de la base
- Nombre de requêtes lentes (>5s)

## 7. Cas d'étude : optimisation réelle
Avant :
-- 10M lignes, 30 secondes
```sql
SELECT *
FROM olist_orders_dataset
WHERE year = 2025
ORDER BY order_purchase_timestamp DESC;
```

Problèmes :
- `SELECT *` (trop de colonnes)
- Pas d'index sur `year`
- Scan complet

Après :
-- Ajout index
```sql
CREATE INDEX idx_olist_orders_year_purchase
ON olist_orders_dataset(year, order_purchase_timestamp DESC);

-- Requête optimisée
SELECT order_id, order_purchase_timestamp, order_status
FROM olist_orders_dataset
WHERE year = 2025
ORDER BY order_purchase_timestamp DESC
LIMIT 100;
```
-- Résultat : 0.05 secondes (600x plus rapide !)

## Exercice final : optimisation complète
Optimisez cette requête :
```sql
SELECT *
FROM olist_order_items_dataset oi
WHERE oi.product_id IN (
    SELECT p.product_id
    FROM olist_products_dataset p
    WHERE UPPER(p.product_category_name) = 'CAMA_MESA_BANHO'
)
ORDER BY oi.price DESC;
```

Solution possible :
```sql
-- 1. Index
CREATE INDEX idx_olist_products_category
ON olist_products_dataset(product_category_name);

CREATE INDEX idx_olist_order_items_product_price
ON olist_order_items_dataset(product_id, price DESC);

-- 2. Requête optimisée
WITH target_products AS (
    SELECT product_id
    FROM olist_products_dataset
    WHERE product_category_name = 'cama_mesa_banho'
)
SELECT oi.order_id, oi.product_id, oi.price, oi.freight_value
FROM olist_order_items_dataset oi
JOIN target_products tp ON tp.product_id = oi.product_id
ORDER BY oi.price DESC
LIMIT 100;
```

Améliorations :
- Colonnes spécifiques (pas *)
- CTE pour éviter la sous-requête imbriquée
- Pas de fonction sur `product_category_name` (pas UPPER())
- Limit pour pagination
- Index sur les colonnes utilisées dans le JOIN et l'ORDER BY

Résumé
- Partitionnement : Diviser les grandes tables pour accélérer les scans
- Vues matérialisées : Pré-calculer les agrégations
- Pagination : Préférer la keyset pagination au OFFSET