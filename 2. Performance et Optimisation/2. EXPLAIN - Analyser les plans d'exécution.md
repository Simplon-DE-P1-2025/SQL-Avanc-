# EXPLAIN - Analyser les plans d'exécution

## Introduction
`EXPLAIN` montre le plan d'exécution d'une requête : comment le moteur SQL la traite.

## Syntaxe
```sql
EXPLAIN
SELECT *
FROM olist_orders_dataset
WHERE year = 2025;
```

## Lecture d'un plan EXPLAIN
Opérations courantes :
- `SEQ_SCAN` : scan complet (lent si table grande)
- `INDEX_SCAN` / `INDEX_LOOKUP` : utilise un index (rapide)
- `HASH_JOIN` (Join avec table de hachage - rapide) / `NESTED_LOOP_JOIN` (Boucles imbriquées - lent) / `MERGE_JOIN` (Fusion de tables triées) : types de jointures
- `FILTER` (Application de WHERE), `PROJECTION` (Sélection de colonnes), `AGGREGATE` (GROUP BY, SUM, COUNT), `ORDER` (Tri ORDER BY): étapes classiques

## EXPLAIN ANALYZE - Avec timing réel
```sql
EXPLAIN ANALYZE
SELECT
    o.order_id,
    SUM(oi.price + oi.freight_value) AS order_total
FROM olist_orders_dataset o
JOIN olist_order_items_dataset oi ON oi.order_id = o.order_id
WHERE o.order_purchase_timestamp >= '2018-01-01'
GROUP BY o.order_id;
```

Affiche :
- Plan d'exécution
- Temps réel
- Nombre de lignes traitées
- Mémoire utilisée

## Identifier les problèmes
### Problème 1 : scan complet
```sql
EXPLAIN
SELECT *
FROM olist_orders_dataset
WHERE year = 2025;
```
-- Résultat : SEQ_SCAN (mauvais si table grande)

Solution : créer un index sur `year`.

### Problème 2 : jointure coûteuse (Nested loop join)
```sql
EXPLAIN
SELECT o.order_id, oi.product_id
FROM olist_orders_dataset o
JOIN olist_order_items_dataset oi ON oi.order_id = o.order_id;
```
Solution : indexer les colonnes de jointure (`order_id`, `product_id` selon besoin).

### Problème 3 : tri coûteux (Sort sans index)
```sql
EXPLAIN
SELECT order_id, order_purchase_timestamp
FROM olist_orders_dataset
ORDER BY age DESC;
```
Solution : index sur `age` ou accepter le tri.

## Coûts estimés
Le moteur estime un coût par opération (ex. `cost=123 rows=456`).
Plus le coût est bas, mieux c'est.

## Exercice
Comparez les plans de :

```sql
-- Requête 1
SELECT *
FROM olist_orders_dataset
WHERE order_status = 'delivered';

-- Requête 2
SELECT order_id, customer_id
FROM olist_orders_dataset
WHERE order_status = 'delivered';
```

Solution

La requête 2 est plus rapide pour les raisons suivantes :
Moins de colonnes à lire (projection réduite)
Moins de données à transférer
Même nombre d’analyses, mais charge de travail moindre

Résumé
- EXPLAIN : Afficher le plan d’exécution 
- EXPLAIN ANALYZE : Temps d’exécution réel 
- SEQ_SCAN : Lent (analyse complète de la table) 
- INDEX_SCAN : Rapide (utilisation de l’index) 
- Coût : Comparer les plans d’exécution
