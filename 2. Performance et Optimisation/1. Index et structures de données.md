# Index et structures de données

## Introduction
Les index accélèrent les recherches en créant des structures de données optimisées. Cela fonctionne comme une table des matières d'un livre qui permet d'accéder directement à la bonne page.

## Concept d'index
Sans index : scan complet (lecture de toutes les lignes).

Avec index : recherche ciblée.

## Types d'index courants
### 1. B-Tree Index (par défaut)
Idéal pour :
- Comparaisons (`=`, `<`, `>`, `BETWEEN`)
- Tris (`ORDER BY`)
- Préfixes (`LIKE 'abc%'`)

```sql
CREATE INDEX idx_olist_orders_purchase_ts
ON olist_orders_dataset(order_purchase_timestamp);

CREATE INDEX idx_olist_products_category
ON olist_products_dataset(product_category_name);
```

### 2. Hash Index
Idéal pour :
- Égalités strictes (`=`)
- Clés primaires

Non supporté selon moteurs : `<`, `>`, `LIKE`, `ORDER BY`.

### 3. Index composites
Index sur plusieurs colonnes :

```sql
CREATE INDEX idx_olist_orders_customer_purchase
ON olist_orders_dataset(customer_id, order_purchase_timestamp DESC);
```

Utilise l'index :
- `WHERE customer_id = '9ef432eb6251297304e76186b10a928d'` -> Oui
- `WHERE customer_id = '9ef432eb6251297304e76186b10a928d' AND order_purchase_timestamp >= '2018-01-01'` -> Oui
- `WHERE order_purchase_timestamp >= '2018-01-01'` -> Non (il manque `customer_id`)

## Quand créer un index ?
Index utiles :
- Colonnes fréquemment utilisées dans la clause `WHERE`
- Colonnes de la clause `JOIN ON`
- Colonnes de la clause `ORDER BY`
- Clés étrangères
- Colonnes à forte cardinalité

Index inutiles :
- Petites tables (< 1 000 lignes)
- Colonnes rarement utilisées
- Colonnes à faible cardinalité (ex. : `order_status`)
- Colonnes fréquemment modifiées

## Exemples d'optimisation
Sans index (lent) :

-- Simulation : Scanner 1M lignes pour trouver 1 id
```sql
SELECT *
FROM olist_orders_dataset
WHERE customer_id = '9ef432eb6251297304e76186b10a928d';
```
-- Scan complet : 10 lignes lues

Avec index (rapide) :
-- Avec index sur title : Lookup direct
-- 1 seule ligne lue 
```sql
CREATE INDEX idx_olist_orders_customer
ON olist_orders_dataset(customer_id);

SELECT *
FROM olist_orders_dataset
WHERE customer_id = '9ef432eb6251297304e76186b10a928d';
```

## Compromis des index
Avantages :
- Lectures plus rapides
- Tri optimisé
- JOIN plus efficaces

Inconvénients :
- Espace disque supplémentaire
- `INSERT/UPDATE/DELETE` plus lents
- Maintenance nécessaire

Règle d'or : indexer les colonnes lues souvent, pas celles modifiées souvent.

## Index utiles sur Olist
-- Index automatique sur clé primaire : id
-- Index utiles à créer :
-- - pour GROUP BY
-- - pour filtres temporels
-- - pour recherches produit

```sql
-- Recherche commandes client
CREATE INDEX idx_olist_orders_customer ON olist_orders_dataset(customer_id);

-- Filtres temporels
CREATE INDEX idx_olist_orders_purchase_ts ON olist_orders_dataset(order_purchase_timestamp);

-- Jointure et analyses produit
CREATE INDEX idx_olist_order_items_product ON olist_order_items_dataset(product_id);
```

## Vérifier l'utilisation des index
```sql
EXPLAIN
SELECT *
FROM olist_orders_dataset
WHERE customer_id = '9ef432eb6251297304e76186b10a928d';
```

## Exercice
Dans une table Olist de commandes volumineuse, quelles colonnes indexer ?
- `order_id` (clé primaire)
- `customer_id` (jointures + filtres)
- `order_purchase_timestamp` (filtres temporels)
- `order_status` (faible cardinalité, à évaluer)

Résumé

- Index : Structure de données utilisée pour accélérer les requêtes 
- Arbre B : Index par défaut (utilisé pour la comparaison et le tri) 
- Compromis : Vitesse de lecture versus espace de stockage/écriture 
- Principe : Créer des index pour les colonnes fréquemment consultées plutôt que pour celles fréquemment modifiées.